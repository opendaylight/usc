<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libnetconf: Transaction API (transAPI)</title>

<link href="../../tabs.css" rel="stylesheet" type="text/css"/>
<link href="../../doxygen.css" rel="stylesheet" type="text/css" />
<link href="../../navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../jquery.js"></script>
<script type="text/javascript" src="../../resize.js"></script>
<script type="text/javascript" src="../../navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="../../search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="../../search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>

</head>
<body>
<div id="top"><!-- do not remove this div! -->


<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  
  <td id="projectlogo"><img alt="Logo" src="../../libnetconf-logo.png"/></td>
  
  
  <td style="padding-left: 0.5em;">
   <div id="projectname">libnetconf
   &#160;<span id="projectnumber">0.9.0-48_trunk</span>
   </div>
   <div id="projectbrief">NETCONF Library</div>
  </td>
  
  
  
 </tr>
 </tbody>
</table>
</div>

<!-- Generated by Doxygen 1.7.6.1 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "../../search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="../../index.html"><span>Main&#160;Page</span></a></li>
      <li class="current"><a href="../../pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="../../modules.html"><span>Modules</span></a></li>
      <li><a href="../../annotated.html"><span>Data&#160;Structures</span></a></li>
      <li><a href="../../files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="../../search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="../../search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
</div>
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
  initNavTree('d9/d25/transapi.html','../../');
</script>
<div id="doc-content">
<div class="header">
  <div class="headertitle">
<div class="title">Transaction API (transAPI) </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Libnetconf transAPI is a framework designed to save developers time and let them focus on configuring and managing their device instead of fighting with the NETCONF protocol.</p>
<p>It allows a developer to choose parts of a configuration that can be easily configured as a single block. Based on a list of so called 'sensitive paths' the generator creates C code containing a single callback function for every 'sensitive path'. Whenever something changes in the configuration file, the appropriate callback function is called and it is supposed to reflect configuration changes in the actual device behavior.</p>
<p>Additionaly, transAPI provides an opportunity to implement behavior of NETCONF RPC operation defined in the data model. In case *lnctool(1)* finds an RPC definition inside the provided data model, it generates callbacks for it too. Whenever a server calls <a class="el" href="../../db/d67/group__store.html#gaabfd0bf6abeaf40659043bf082e14801" title="Perform the requested RPC operation on the datastore.">ncds_apply_rpc()</a> or <a class="el" href="../../db/d67/group__store.html#ga6e6e979bd82e50913c82b4dc37cb8759" title="Perform the requested RPC operation on the all datastores controlled by the libnetconf (created by nc...">ncds_apply_rpc2all()</a> with RPC message containing such defined RPC operation, libnetconf uses callback function implemented in the module.</p>
<h2><a class="anchor" id="understanding-parameters"></a>
Understanding callback parameters</h2>
<p>Every transapi callback function has fixed set of parameters. Function header looks like this:</p>
<p>~~~~~~~{.c} int callback_path_into_configuration_xml(void **data, XMLDIFF_OP op, xmlNodePtr node, struct nc_err **error) ~~~~~~~</p>
<h3><a class="anchor" id="data"></a>
void **data</h3>
<p>This parameter was added to provide a way to share any data between callbacks. libnetconf never change (or even access) content of this parameter. Initialy content of 'data' is NULL. transapi module may use 'data' as it like but is also fully responsible for correct memory handling and freeing of no longer needed memory referenced by 'data'.</p>
<h3><a class="anchor" id="op"></a>
XMLDIFF_OP op</h3>
<p>Parameter op indicates what event(s) was occured on node. All events are bitwise ored. To test if certaint event occured on node use bitwise and (&amp;).</p>
<ul>
<li>Node can be added or removed.<ul>
<li>XMLDIFF_ADD = Node was added.</li>
<li>XMLDIFF_REM = Node was removed.</li>
</ul>
</li>
<li>Nodes of type leaf can be changed.<ul>
<li>XMLDIFF_MOD = node content was changed</li>
</ul>
</li>
<li>Container nodes are informed about events occured on descendants. It can be distinguished whether the event was processed or not.<ul>
<li>XMLDIFF_MOD = Some of node children was changed and there is not callback specified for it.</li>
<li>XMLDIFF_CHAIN = Some of node children was changed and associated callback was called.</li>
</ul>
</li>
<li>Additionaly, user-ordered lists and leaf-lists are notified when change in order occurs.<ul>
<li>XMLDIFF_SIBLING = Change in order. Some of siblings was added, removed or changed place.</li>
<li>XMLDIFF_REORDER = Undrelying user-ordered list has changed order.</li>
</ul>
</li>
</ul>
<h4><a class="anchor" id="combinations"></a>
Valid combinations of events</h4>
<ul>
<li>XMLDIFF_ADD and XMLDIFF_REM can never be specified simutaneously.</li>
<li>other restrictions depend on node type:<ul>
<li>Leaf: exactly one of XMLDIFF_ADD, XMLDIFF_REM, XMLDIFF_MOD</li>
<li>Container: at least one of XMLDIFF_ADD, XMLDIFF_REM, XMLDIFF_MOD, XMLDIFF_CHAIN and posibly XMLDIFF_REORDER when node holds user-ordered list</li>
<li>List (system-ordered): at least one of XMLDIFF_ADD, XMLDIFF_REM, XMLDIFF_MOD, XMLDIFF_CHAIN and posibly XMLDIFF_REORDER when node holds user-ordered list</li>
<li>List (user-ordered): at least one of XMLDIFF_ADD, XMLDIFF_REM, XMLDIFF_MOD, XMLDIFF_CHAIN, XMLDIFF_SIBLING and posibly XMLDIFF_REORDER when node holds user-ordered list</li>
<li>Leaf-list (system-ordered): exactly one of XMLDIFF_ADD, XMLDIFF_REM</li>
<li>Leaf-list (user-ordered): at least one of XMLDIFF_ADD, XMLDIFF_REM, XMLDIFF_SIBLING</li>
</ul>
</li>
</ul>
<p>Ex.: Leaf processing ~~~~~~~{.c} int callback_some_leaf(void **data, XMLDIFF_OP op, xmlNodePtr node, struct nc_err **error) { if (op &amp; XMLDIFF_MOD) { // change configured value } else if (op &amp; XMLDIFF_REM) { // leaf removed (disable service, close port, ...) } else if (op &amp; XMLDIFF_ADD) { // leaf added (enable service, open port, ...) } else { *error = nc_err_new(NC_ERR_OP_FAILED); nc_err_set(error, NC_ERR_PARAM_MSG, "Invalid event for leaf node /some/leaf."); return(EXIT_FAILURE); } return(EXIT_SUCCESS); } ~~~~~~~</p>
<h3><a class="anchor" id="node"></a>
xmlNodePtr node</h3>
<p>Pointer to a particular node instance in configuration document where the event was detected. When the node was removed pointer is set to its instance in old configuration snapshot.</p>
<h3><a class="anchor" id="error"></a>
strict nc_err **error</h3>
<p>libnetconf's error structure. May (and should) be used to specify error when it occurs and callback returns EXIT_FAILURE. Error description is forwarded to client.</p>
<h2><a class="anchor" id="transAPI-history"></a>
History of the transAPI versions</h2>
<p>Each transAPI module source code is generated with the ``transapi_version`` variable set to the transAPI version supported by the code generator (*lnctool(1)*). libnetconf requires exactly the same transAPI version in the modules as it supports itself. However, some of the transAPI versions are kind of backward compatible, so it is possible to simply change the value of the ``transapi_version`` variable in the module source code. In that case no additional changes to the transAPI module source code are required.</p>
<p>Here is the list of transAPI versions with notes to the changed things and to the backward compatibility.</p>
<ul>
<li>*version 1*<ul>
<li>Initial reversion.</li>
</ul>
</li>
<li>*version 2*<ul>
<li>Allow callbacks to modify configuration data. This action is announced by the callback via the ``config_modified`` variable.</li>
<li>Changes prototype of the transAPI callbacks. It allows to return NETCONF error description structure from the callbacks.</li>
<li>Backward incompatible.</li>
</ul>
</li>
<li>*version 3*<ul>
<li>Changes prototype of the ``transapi_init()`` function. It allows the module can announce to libnetconf the initial configuration of the device when the module is loaded.</li>
<li>Changes prototype of the transAPI callbacks. The configuration data are passed to the callbacks only as the libxml2 structures. Callbacks variant passing configuration data as strings are no longer available.</li>
<li>Backward incompatible.</li>
</ul>
</li>
<li>*version 4*<ul>
<li>Callback order - the module can change the order of executing callbacks from the default 'from leafs to root` to 'from root to leafs`. This is done via the ``callbacks_order`` variable. If the variable is not defined (such as in a transAPI v3 module), the default callback order is used.</li>
<li>Backward compatible.</li>
</ul>
</li>
<li>*version 5*<ul>
<li>Adds support for monitoring external files.</li>
<li>Backward compatible.</li>
</ul>
</li>
</ul>
<h2><a class="anchor" id="transapiTutorial"></a>
transAPI Tutorial</h2>
<p>[netopeer]: <a href="https://code.google.com/p/netopeer">https://code.google.com/p/netopeer</a></p>
<p>On this page we will show how to write a simple module for controlling [example toaster](<a href="http://netconfcentral.org/modulereport/toaster">http://netconfcentral.org/modulereport/toaster</a>). </p>
<dl class="note"><dt><b>Note:</b></dt><dd>To install libnetconf follow the instructions on the <a class="el" href="../../d9/d87/install.html">Compilation and Installation</a> page.</dd></dl>
<h3><a class="anchor" id="transapiTutorial-prepare"></a>
Preparations</h3>
<p>In this example we will work with the data model of the toaster provided by Andy Bierman at NETCONF CENTRAL (&lt;<a href="http://dld.netconfcentral.org/src/toaster@2009-11-20.yang">http://dld.netconfcentral.org/src/toaster@2009-11-20.yang</a>&gt;).</p>
<p>First, we need to identify important parts of the configuration data. Since the toaster data model describes only one configurable element, we have an easy choice. So, we can create the 'paths_file' file containing the specification of our chosen element and mapping prefixes with URIs for any used namespace.</p>
<p>Our file may look like this (irrespective of order): ~~~~~~~{.xml} toaster=<a href="http://netconfcentral.org/ns/toaster">http://netconfcentral.org/ns/toaster</a> /toaster:toaster ~~~~~~~</p>
<h3><a class="anchor" id="transapiTutorial-generating"></a>
Generating code</h3>
<ol type="1">
<li>Create a new directory for the toaster module and move the data model and the path file into it: ~~~~~~~{.sh} $ mkdir toaster &amp;&amp; cd toaster/ $ mv ../toaster@2009-11-20.yang ../paths_file . ~~~~~~~</li>
<li>Run *lnctool(1)* for transapi: ~~~~~~~{.sh} $ lnctool --model ./toaster@2009-11-20.yang transapi --paths ./paths_file ~~~~~~~</li>
</ol>
<p>Besides the generated source code of our transAPI module and GNU Build System files (Makefile.in, configure.in,...), *lnctool(1)* also generates YIN format of the data model and validators accepted by the libnetconf's <a class="el" href="../../d8/d55/group__transapi.html#ga80e69b4cada8c35e5e358287e8af3d85" title="Create new datastore structure with transaction API support.">ncds_new_transapi()</a> and <a class="el" href="../../db/d67/group__store.html#ga4777c16043f5856c5a65bcd20b5ecc31" title="Set validators (or disable validation) on the specified datastore.">ncds_set_validation()</a> functions:</p>
<ul>
<li>*.yin - YIN format of the data model</li>
<li>*.rng - RelagNG schema for syntax validation</li>
<li>*-schematron.xsl - Schematron XSL stylesheet for semantics validation</li>
</ul>
<p>The data model can define various `feature`s and use them via the `if-feature` clauses. By default, all features are enabled for the validators. If you plan to to implement only a specific set (or none) of features, specify it to using the `--feature`` option (that can be used multiple times). The value has the following syntax:</p>
<p>~~~~~~~{.sh} --feature module_name:feature_to_enable ~~~~~~~</p>
<p>If you want to disable all features of the module, use the following syntax:</p>
<p>~~~~~~~{.sh} --feature module_name: ~~~~~~~</p>
<h3><a class="anchor" id="transapiTutorial-augmenting"></a>
Augmenting module</h3>
<p>When you are adding a model augmenting the original model, you have generally 2 ways of doing so: <br/>
</p>
<ol type="1">
<li>Create a new transAPI module implementing the original model with any augments, basically treating it as a single model. This way you receive a standalone transAPI module that will make the original module obsolete. *lnctool(1)* command: ~~~~~~~{.sh} $ lnctool --model &lt;original_model&gt; --augment-model &lt;augment_model&gt; transapi --path &lt;paths_for_original_and_augment_model&gt; ~~~~~~~ <br/>
</li>
<li>Create a new transAPI module implementing only the augmented parts. This way you receive an additional module that will be used together with the original module, which does not need to be modified in any way. *lnctool(1)* command: ~~~~~~~{.sh} $ lnctool --model &lt;augment_model&gt; transapi --path &lt;paths_for_augment_model&gt; ~~~~~~~</li>
</ol>
<p><br/>
 However, the case when a model is augmenting na RPC in the original model must be treated specially. Firstly, ONLY the first way of augmenting a module can and MUST be used. Secondly, after issuing the *lnctool(1)* command, the generated code will be INCORRECT and must be changed manually for it to work properly. Illustrated on an example: <br/>
<br/>
 The original model has an RPC 'my-rpc' with a single argument 'arg1'. Augment model is adding another argument 'arg2'. The original module 'my-rpc' code and the newly generated code will be the same: ~~~~~~~{.c} nc_reply *rpc_my_rpc(xmlNodePtr input[]) { xmlNodePtr arg1 = input[0];</p>
<p>return NULL; }</p>
<p>struct <a class="el" href="../../d0/df8/structtransapi__rpc__callbacks.html" title="Same as transapi_rpc_callbacks. Using libxml2 structures for callbacks parameters.">transapi_rpc_callbacks</a> rpc_clbks = { .callbacks_count = 1, .callbacks = { {.name="my-rpc", .func=rpc_my_rpc, .arg_count=1, .arg_order={"arg1"}} } }; ~~~~~~~ To be able to work with the second argument 'arg2', the code must be changed to: ~~~~~~~{.c} nc_reply *rpc_my_rpc(xmlNodePtr input[]) { xmlNodePtr arg1 = input[0]; xmlNodePtr arg2 = input[1];</p>
<p>return NULL; }</p>
<p>struct <a class="el" href="../../d0/df8/structtransapi__rpc__callbacks.html" title="Same as transapi_rpc_callbacks. Using libxml2 structures for callbacks parameters.">transapi_rpc_callbacks</a> rpc_clbks = { .callbacks_count = 1, .callbacks = { {.name="my-rpc", .func=rpc_my_rpc, .arg_count=2, .arg_order={"arg1", "arg2"}} } }; ~~~~~~~ This pattern can be used with several augment models, all changing a single RPC.</p>
<h3><a class="anchor" id="transapiTutorial-coding"></a>
Filling up functionality</h3>
<p>Here we show the simplest example of a toaster simulating module. It is working but does not deal with multiple access and threads correctly. Better example may can be found in the netopeer-server-sl source codes located in the [Netopeer project][netopeer] repository (server-sl/toaster/toaster.c).</p>
<ol type="1">
<li>Open 'toaster.c' file with your favorite editor:<br/>
<br/>
 ~~~~~~~{.sh} $ vim toaster.c ~~~~~~~ <br/>
</li>
<li>Add global variables and auxiliary functions. This is completely up to you, libnetconf does not work with this anyway.<br/>
<br/>
 ~~~~~~~{.c} enum {ON, OFF, BUSY} status; pthread_t thread;</li>
</ol>
<p>void * auxiliary_make_toast(void * time) { sleep(*(int*)time);</p>
<p>if (status == BUSY) { status = ON; ncntf_event_new(-1, NCNTF_GENERIC, "&lt;toastDone&gt;&lt;toastStatus&gt;done&lt;/toastStatus&gt;&lt;/toastDone&gt;"); } return(NULL); } ~~~~~~~ <br/>
</p>
<ol type="1">
<li>Complete the 'transapi_init()' function with actions that will be run right after the module loads and before any other function in the module is called.<br/>
<br/>
 The 'running' parameter can optionally return the current configuration state of the device as the 'transapi_init()' detects it. The configuration must correspond with the device data model and it is supposed to contain only the configuration data (defined with 'config true`). The returned data are then compared with the startup configuration and only the diverging values are set according to the startup content using the appropriate transAPI callback functions.<br/>
<br/>
 We ignore it in our example - the toaster is on each start without the root element, which means that it is supposed to be switched off. Then it is up to the startup content if the toaster will be turned on.<br/>
<br/>
 ~~~~~~~{.c} int transapi_init(xmlDocPtr * running) { status = OFF; printf("Toaster initialized!\n"); return(EXIT_SUCCESS); } ~~~~~~~ <br/>
</li>
<li>Locate the 'transapi_close()' function and fill it with actions that will be run just before the module unloads. No other function of the transAPI module is called after the 'transapi_close()'.<br/>
<br/>
 ~~~~~~~{.c} void transapi_close() { printf("Toaster ready for unplugging!\n"); } ~~~~~~~ <br/>
</li>
<li>Fill 'get_state_data()' function. This function returns (only!) the state data (defined with 'config false').<br/>
<br/>
 ~~~~~~~{.c} char * get_state_data(char * model, char * running, struct nc_err **err) { return strdup("&lt;?xml version="1.0"?&gt;&lt;toaster xmlns="<a href="http://netconfcentral.org/ns/toaster">http://netconfcentral.org/ns/toaster</a>"&gt; ... &lt;/toaster&gt;"); } ~~~~~~~ <br/>
</li>
<li>Complete the configuration callbacks (they have the `callback_` prefix). The 'op' parameter can be used to determine operation which was done with the node. Parameter 'node' holds a copy of node after change (or before change if op == XMLDIFF_REM).<br/>
<br/>
 More detailed information about the callback parameters can be found above in the <a class="el" href="../../d9/d25/transapi.html#understanding-parameters">Understanding callback parameters</a> section.<br/>
<br/>
 ~~~~~~~{.c} int callback_toaster_toaster (void ** data, XMLDIFF_OP op, xmlNodePtr node, struct nc_err** error) { if (op &amp; XMLDIFF_ADD) { status = ON; } else if (op &amp; XMLDIFF_REM) { status = OFF; } else { *error = nc_err_new(NC_ERR_OP_FAILED); nc_err_set(*error, NC_ERR_PARAM_MSG, "Unsupported operation."); return(EXIT_FAILURE); } return(EXIT_SUCCESS); } ~~~~~~~ <br/>
</li>
<li>Fill the RPC message callback functions with the code that will be run when an RPC message with the defined operation arrives.<br/>
<br/>
 ~~~~~~~ nc_reply * rpc_make_toast (xmlNodePtr input[]) { xmlNodePtr toasterDoneness = input[0]; xmlNodePtr toasterToastType = input[1];</li>
</ol>
<p>nc_reply * reply; int doneness = atoi(xmlNodeGetContent(toasterDoneness));</p>
<p>if (status == ON) { status = BUSY; pthread_create(&amp;thread, NULL, auxiliary_make_toast, (void*)&amp;doneness); pthread_detach(thread); reply = <a class="el" href="../../d0/de2/group__reply.html#ga047f565bb3671ec4016fef5461e8f67e" title="Create &lt;ok&gt; rpc-reply response.">nc_reply_ok()</a>; } else { reply = nc_reply_error(nc_err_new(NC_ERR_OP_FAILED)); } return(reply); } ~~~~~~~ ~~~~~~~ nc_reply * rpc_cancel_toast (xmlNodePtr input[]) { nc_reply * reply;</p>
<p>if (status == BUSY) { status = ON; ncntf_event_new(-1, NCNTF_GENERIC, "&lt;toastDone&gt;&lt;toastStatus&gt;canceled&lt;/toastStatus&gt;&lt;/toastDone&gt;"); reply = <a class="el" href="../../d0/de2/group__reply.html#ga047f565bb3671ec4016fef5461e8f67e" title="Create &lt;ok&gt; rpc-reply response.">nc_reply_ok()</a>; } else { reply = nc_reply_error(nc_err_new(NC_ERR_OP_FAILED)); } return(reply); } ~~~~~~~ <br/>
</p>
<ol type="1">
<li>Optionally, you can set monitoring for some external configuration file.<br/>
<br/>
 Let's say, that our toaster has a textual configuration located in the `/etc/toaster.conf` file. libnetconf can monitor this file for modification and whenever an external application changes content of the file, the specified callback is executed. It's up to the callback function to open the file for reading and update get the current configuration data.<br/>
<br/>
 ~~~~~~~ int example_callback(const char *filepath, xmlDocPtr *running, int* execflag) { // do nothing *running = NULL; *execflag = 0;</li>
</ol>
<p>return(EXIT_SUCCESS); }</p>
<p>struct <a class="el" href="../../de/df8/structtransapi__file__callbacks.html" title="Functions to call if the specified file is modified.">transapi_file_callbacks</a> file_clbks = { .callbacks_count = 1, .callbacks = {{.path = "/etc/toaster.conf", .func = example_callback}} }; ~~~~~~~ <br/>
 Here is the description of the callback function parameters:<br/>
</p>
<ul>
<li>**const char *filepath** - input parameter providing the path to the changed file</li>
<li>**xmlDocPtr *edit_config** - output parameter to return content for the `edit-config` operation to change the content of the NETCONF running datastore.</li>
<li>**int *exec** - output parameter to set if the performed changes should cause execution of the regular transAPI callbacks. If set to `0`, the changes are only reflected in the running configuration datastore, but no transAPI callback is executed.<br/>
<br/>
</li>
</ul>
<p>Done</p>
<h3><a class="anchor" id="transapiTutorial-compiling"></a>
Compiling module</h3>
<p>Following sequence of commands will produce the shared library 'toaster.so' which may be loaded into libnetconf: ~~~~~~~{.sh} $ autoreconf $ ./configure $ make ~~~~~~~</p>
<h3><a class="anchor" id="transapiTutorial-using"></a>
Integrating to a server</h3>
<p>In a server we use libnetconf's function <a class="el" href="../../d8/d55/group__transapi.html#ga80e69b4cada8c35e5e358287e8af3d85" title="Create new datastore structure with transaction API support.">ncds_new_transapi()</a> instead of <a class="el" href="../../db/d67/group__store.html#ga69009c5985f9eec3a6920f98a6a1a5e6" title="Create a new datastore structure of the specified implementation type.">ncds_new()</a> to create a transAPI-capable data store. Then, you do not need to process any data-writing (edit-config, copy-config, delete-config, lock, unlock), data-reading (get, get-config) or module data-model-defined RPC operations. All these operations are processed inside the <a class="el" href="../../db/d67/group__store.html#ga6e6e979bd82e50913c82b4dc37cb8759" title="Perform the requested RPC operation on the all datastores controlled by the libnetconf (created by nc...">ncds_apply_rpc2all()</a> function. </p>
</div></div><!-- contents -->
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Defines</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div>
  <div id="nav-path" class="navpath">
    <ul>

    <li class="footer">Generated on Tue Mar 3 2015 14:10:21 for libnetconf by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.7.6.1 </li>
   </ul>
 </div>


</body>
</html>
